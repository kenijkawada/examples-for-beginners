# Priority Queue

優先度付きキュー（Priority Queue）は、通常のキューと同様に、要素を保持するデータ構造ですが、各要素に優先度が割り当てられています。優先度付きキューでは、要素が追加されるとき、それぞれの要素は特定の優先度に基づいてキュー内で適切な位置に配置されます。そして、要素の取り出しは優先度が最も高い要素から行われます。これは、全ての要素が同等に扱われる通常のキュー（先入れ先出し）とは異なります。

優先度付きキューの特徴：

1. **挿入時の優先度の割り当て**:
   要素が優先度付きキューに挿入される際、それぞれの要素には優先度が割り当てられます。この優先度に基づいて、要素はキュー内で適切な位置に配置されます。
2. **優先度に基づく取り出し**:
   要素の取り出しは、優先度が最も高い要素から行われます。優先度が同じ要素が複数ある場合は、それらの要素の中で最初に挿入された要素が最初に取り出されます（FIFO 原則）。
3. **動的な操作**:
   新しい要素が追加されるたびに、キューは再構築され、要素が適切な位置に配置されます。また、要素の取り出しもキューの再構築を必要とすることがあります。

優先度付きキューは、CPU スケジューリング、ダイクストラのアルゴリズムなどのグラフ探索アルゴリズム、ハフマン符号化などのデータ圧縮アルゴリズムなど、多くの計算用途に使用されます。

優先度付きキューの実装には、配列、連結リスト、バイナリヒープ（最も一般的）など、さまざまなデータ構造が使用されます。バイナリヒープを使用すると、要素の挿入と削除の両方を効率的に（一般に O(log n)の時間複雑度で）行うことができます。

# priorityQueueV1.js と priorityQueueUsingBinaryQueue.js の比較

二つの`PriorityQueue`実装を比較すると、バイナリヒープを使用する方が効率的です。

### 配列ベースの優先度付きキュー（priorityQueueV1.js）

最初の実装では、内部的に配列（`this.items`）を使用しており、`enqueue`操作のために優先度を比較しながら正しい位置を探しています。この実装の欠点は、`enqueue`操作に O(n)の時間がかかることです。なぜなら、最悪の場合には配列の各要素をチェックし、適切な位置に要素を挿入するために他の要素をシフトする必要があるからです。`dequeue`操作は O(1)ですが、配列の先頭要素を削除する際に他の全要素をシフトするため、配列が大きい場合にはそれなりのコストがかかります。

### バイナリヒープベースの優先度付きキュー（priorityQueueUsingBinaryQueue.js）

二つ目の実装では、内部的にバイナリヒープ（この場合は最小ヒープ）を使用しています。ヒープは、要素の追加（`enqueue`）と削除（`dequeue`）について効率的な操作を提供します。`enqueue`操作では、要素はヒープの末尾に追加され、その後バブルアップ操作によって O(log n)の時間で適切な位置に移動されます。`dequeue`操作も同様に、ルート要素の削除とヒープの最後の要素のルートへの移動、それに続くシンクダウン操作によって O(log n)の時間で行われます。

### 効率性の比較

- **時間複雑度**:

  - 配列ベースの実装では、`enqueue`が O(n)、`dequeue`が最悪の場合 O(n)です（配列のシフトによる）。
  - バイナリヒープベースの実装では、`enqueue`と`dequeue`がともに O(log n)です。

- **スペース複雑度**:
  - 両方の実装ともに O(n)ですが、バイナリヒープの方が一般的に要素の挿入と削除においてメモリのオーバーヘッドが少ないです。

したがって、大量の要素を処理する場合や、頻繁に要素の挿入や削除が行われる場合、バイナリヒープを使用した二つ目の`PriorityQueue`実装の方がはるかに効率的です。
