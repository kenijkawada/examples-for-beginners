# Max Heap

各ノードの値はその子ノードの値よりも大きいか等しいです。つまり、ヒープのルートには最大値が格納されます。

## 最大ヒープ（Max Heap）の形成の流れ

`[12, 10, -20, 100]` の値を最大ヒープに挿入するプロセスをステップバイステップで説明します。

このプロセスでは、各要素をヒープに追加し、ヒープの性質を維持するために必要な場合にはバブルアップ（上方への移動）操作を行います。

`[12, 10, -20, 100]`の値を最大ヒープに挿入するプロセスを説明します。このプロセスでは、各要素をヒープに追加し、ヒープの性質を維持するために必要な場合にはバブルアップ（上方への移動）操作を行います。

#### ステップ 1: 最初の要素（12）の挿入

- 最初の要素`12`をヒープに挿入します。ヒープが空なので、`12`はそのままルートとなります。

ヒープ状態：

```
12
```

#### ステップ 2: 次の要素（10）の挿入

- `10`をヒープに挿入します。`10`は`12`の子として追加されます。
- `10`は親ノードの`12`より小さいため、ヒープの性質に違反していないので、そのままです。

ヒープ状態：

```
  12
 /
10
```

#### ステップ 3: 次の要素（-20）の挿入

- `-20`をヒープに挿入します。`-20`は`12`のもう一方の子として追加されます。
- `-20`は親ノードの`12`より小さいため、ヒープの性質に違反していないので、そのままです。

ヒープ状態：

```
  12
 /  \
10  -20
```

#### ステップ 4: 次の要素（100）の挿入

- `100`をヒープに挿入します。`100`は最初は`10`の子として追加されます。
- `100`は親ノードの`10`より大きいため、ヒープの性質に違反しています。したがって、バブルアップ操作を行います。
- `100`と`10`を交換します。

交換後のヒープ状態：

```
     12
    /   \
  100    -20
 /
10
```

- しかし、`100`は今度は親ノードの`12`よりも大きいため、さらにバブルアップ操作が必要です。
- `100`と`12`を交換します。

最終的なヒープ状態：

```
     100
    /   \
  12    -20
 /
10
```

これで全ての要素が挿入され、各ノードがその子ノードより大きいか等しいため、最大ヒープの性質が保たれています。これが`[12, 10, -20, 100]`の値を最大ヒープに挿入するプロセスです。

## 最大ヒープ（Max Heap）のルートノードの削除の流れ

`[12, 10, -20, 100]`の配列で作成された最大ヒープからルートノードの`100`を削除するプロセスは、以下のステップで行われます。

この例では、ヒープは 0 インデックスベースで、最大ヒープのプロパティを満たしています（各ノードはその子ノードより大きいか等しいです）。

ヒープの初期状態（`100`をルートとする最大ヒープ）:

```
     100
    /   \
  12     -20
 /
10
```

#### ステップ 1: ルートノードの削除

- ルートノード（最大値）`100`を削除します。
- ヒープの最後の要素`10`をルートに移動します。

結果（ルートに`10`が移動）:

```
      10
     /   \
  12     -20
```

#### ステップ 2: ヒープ化

- ルートに移動した`10`は最大ヒープのプロパティに違反している可能性があるため、ヒープ化プロセスを開始します。

#### ステップ 3: シンクダウン操作

- `10`を子ノード`12`と`-20`と比較します。
- `10`は`12`より小さいので、`12`と`10`を交換します。

交換後:

```
     12
    /  \
  10   -20
```

#### ステップ 4: 最終状態のチェック

- 新たに子ノードになった`10`は、それ以上子ノードを持っていません。
- したがって、これ以上交換する必要はありません。

結果（最終的なヒープ）:

```
     12
    /  \
  10   -20
```

これで最大ヒープの性質が保たれ、ルートノードの`100`が削除された後のヒープの再構成が完了しました。各ノードはその子ノードより大きいか等しいです。このようにして、最大ヒープから要素を削除し、ヒープ特性を維持するプロセスが行われます。
