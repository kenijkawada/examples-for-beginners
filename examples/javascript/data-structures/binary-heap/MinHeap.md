# Min Heap

各ノードの値はその子ノードの値よりも小さいか等しいです。つまり、ヒープのルートには最小値が格納されます。

## 最小ヒープ（Min Heap）の形成の流れ

`[12, 10, -20, 100]` の値を最小ヒープに挿入するプロセスをステップバイステップで説明します。

#### ステップ 1: 12 を挿入

最初の要素`12`を挿入します。これが最初の要素なので、直接ルートになります。

```
   12

```

#### ステップ 2: 10 を挿入

次に`10`を挿入します。`10`は`12`より小さいので、ヒープ特性を満たすために`12`との位置を交換します。

```
   10
   /
 12

```

#### ステップ 3: -20 を挿入

次に`-20`を挿入します。`-20`は現在の最小値`10`よりも小さいので、ルートに移動する必要があります。まず`-20`をヒープに追加し、親ノードと比較してヒープ特性を満たすように位置を調整します。

初期挿入:

```
   10
   / \
 12  -20

```

- `20` は`10`より小さいので、位置を交換します。

```
  -20
  /  \
12   10

```

#### ステップ 4: 100 を挿入

最後に`100`を挿入します。`100`は他のどのノードよりも大きいので、位置を交換する必要はありません。

```
   -20
   /  \
 12   10
 /
100

```

この時点で、すべての要素が最小ヒープに挿入され、ヒープ特性が保たれています。親ノードはその子ノードより小さいか等しい値を持ち、ルートノードには最小値があります。ヒープは配列で効率的に表現されるため、上記のツリー構造は理解を助けるための視覚的表現に過ぎませんが、内部的には配列で管理されています。

## 最小ヒープ（Min Heap）のルートノードの削除の流れ

`[12, 10, -20, 100]`の配列を最小ヒープとして考え、ルートノードの`100`を削除するプロセスをステップバイステップで説明します。ただし、提示された配列は最小ヒープの順序を満たしていないように見えますが、この説明の目的のためにそれを最小ヒープと仮定します。

最小ヒープの初期状態（`100`をルートとする最小ヒープ）:

```
     100
    /   \
  12     -20
 /
10
```

#### ステップ 1: ルートノードの削除

- ルートノード（最小値）`100`を削除します。
- ヒープの最後の要素`10`をルートに移動します。

結果（ルートに`10`が移動）:

```
     10
    /   \
  12     -20
```

#### ステップ 2: ヒープ化（Heapify）の開始

- ルートに移動した`10`は最小ヒープのプロパティに違反している可能性があるため、ヒープ化（heapify）プロセスを開始します。

#### ステップ 3: シンクダウン操作

- `10`を子ノード`12`と`-20`と比較します。
- `10`は既に`12`と`-20`より小さいため、最小ヒープの性質に違反していません。
- したがって、この場合、さらなるシンクダウン操作は不要です。

結果（最終的なヒープ）:

```
     10
    /   \
  12     -20
```

これで最小ヒープの性質が保たれ、ルートノードの`100`が削除された後のヒープの再構成が完了しました。各ノードはその子ノードより小さいか等しいです。ただし、本来最小ヒープでは最小値がルートに来るべきなので、`-20`がルートの位置にあるべきですが、問題の前提として与えられた配列が最小ヒープの性質を満たしていないため、このような状況になっています。通常は、ヒープ構造を構築する際には、正しいヒープの性質が保たれるように要素を追加します。
